class CrossOriginInterface{static instances={};constructor(e){if(CrossOriginInterface.instances[e])return console.error("CrossOriginInterface instance already exists with key",e),CrossOriginInterface.instances[e];CrossOriginInterface.instances[e]=this,this.sortedAnchors=[],this.trackedAnchors=new Set,this.anchorVisibleStates={},this.activeAnchorId=null,this.component=null,this.autoUpdateAnchor=!1,this.key=e,this.styles=null,this.disable_scroll=!1,this.updateId=0,this.enroute=!1,this.untrackedanchors=[],window.addEventListener("message",this.handleMessage.bind(this)),setInterval((()=>{this.poll_untrackedanchors()}),200)}register(e,t,s){this.component=e,this.autoUpdateAnchor=t,this.emphasisStyle=s,console.debug("Registered component for key ",this.key,": ",e,t)}updateConfig(e,t){this.styles=e,this.disable_scroll=t,console.debug("Updated config",e,t)}scroll(e){const t=document.getElementById(e);if(console.debug("Scrolling to",e),t){const s=this.disable_scroll?"instant":"smooth";this.anchorVisibleStates[e]||(this.enroute=!0),this.updateActiveAnchor(e),t.scrollIntoView({behavior:s,block:"start"})}this.emphasize(e)}emphasize(e){const t=document.getElementById(e);if(t){if(null===this.styles)return void console.error("Styles have not been set");const s=this.styles.anchorEmphasis||null;if(null===s)return void console.error("emphasisStyle has not been set");console.debug("Emphasizing",e,s);for(const e in s)t.style[e]=s[e];console.debug("Emphasis applied",e,s),setTimeout((()=>{t.style.transform="scale(1)",console.debug("Emphasis removed",e)}),600)}else console.debug("Element does not exist for emphasis",e)}updateActiveAnchor(e){this.trackedAnchors.has(e)?(this.activeAnchorId=e,console.debug("Updated active anchor",e)):console.error("Anchor is not being tracked",e??"null")}checkBestAnchor(){if(!this.enroute&&this.activeAnchorId){if(this.anchorVisibleStates[this.activeAnchorId])return;let e=null;const t=this.sortedAnchors.indexOf(this.activeAnchorId);for(let s=t+1;s<this.sortedAnchors.length;s++){const t=this.sortedAnchors[s];if(this.anchorVisibleStates[t]){e=t;break}}if(null===e)for(let s=t-1;s>=0;s--){const t=this.sortedAnchors[s];if(this.anchorVisibleStates[t]){e=t;break}}null!==e&&(this.activeAnchorId=e,this.postUpdateActiveAnchor(this.activeAnchorId))}}postUpdateActiveAnchor(e){this.postMessage("updateActiveAnchor",{anchor_id:e,update_id:this.updateId++})}postMessage(e,t=({anchor_id:anchor_id=null,update_id:update_id=null}={})){null!==this.component?this.component.postMessage({COMPONENT_method:e,key:this.key,...t},"*"):console.error("Component has not been registered")}observer=new IntersectionObserver((e=>{e.forEach((e=>{const t=e.target.id;e.isIntersecting?(this.anchorVisibleStates[t]=!0,this.activeAnchorId===t&&(this.enroute=!1)):(this.anchorVisibleStates[t]=!1,this.activeAnchorId===t&&setTimeout((()=>{this.checkBestAnchor()}),0))}))}),{threshold:[0,1]});trackAnchors(e){for(const t of e){if(this.trackedAnchors.has(t)){console.debug("Anchor is already being tracked",t);continue}const e=document.getElementById(t);if(!e){console.warn("Anchor does not exist in document: ",t,". Queueing for later."),this.untrackedanchors.push(t);continue}this.trackedAnchors.add(t),null===this.activeAnchorId&&(this.activeAnchorId=t);let s=!1;for(let o=0;o<this.sortedAnchors.length;o++){const n=document.getElementById(this.sortedAnchors[o]);if(e.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_FOLLOWING){this.sortedAnchors.splice(o,0,t),s=!0;break}}s||this.sortedAnchors.push(t),this.observer.observe(e),console.debug("Started tracking anchor",t)}}poll_untrackedanchors(){if(this.untrackedanchors.length>0){const e=this.untrackedanchors;this.untrackedanchors=[],this.trackAnchors(e),console.log("ASDFASDF")}}handleMessage(e){const{COI_method:t,key:s}=e.data;if(t&&s&&s===this.key){if(console.debug("COI with key",s,"received message",e.data),null===this.component)if("register"===t){const{auto_update_anchor:t,emphasis_style:s}=e.data;this.register(e.source,t,s)}else console.error("Must register component with this CrossOriginInterface before calling other methods",e.data);switch(t){case"register":console.debug("Register can only be called once per key.");break;case"updateConfig":const{styles:s,disable_scroll:o}=e.data;this.updateConfig(s,o);break;case"scroll":const{anchor_id:n}=e.data;this.scroll(n);break;case"trackAnchors":const{anchor_ids:i}=e.data;this.trackAnchors(i);break;case"updateActiveAnchor":const{anchor_id:r}=e.data;this.updateActiveAnchor(r);break;default:console.error("Unknown method",t)}}}}function instantiateCrossOriginInterface(e){return new CrossOriginInterface(e)}